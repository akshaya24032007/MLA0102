BFS (Breadth-First Search) – Pseudocode:
BFS(Graph, startNode):
    create an empty Queue Q
    mark startNode as visited
    enqueue startNode into Q
    while Q is not empty:
        currentNode ← dequeue Q
        print currentNode
        for each adjacentNode of currentNode:
            if adjacentNode is not visited:
                mark adjacentNode as visited
                enqueue adjacentNode into Q

DFS:
DFS (Depth-First Search) – Pseudocode:
DFS(Graph, startNode):
    mark startNode as visited
    print startNode

    for each adjacentNode of startNode:
        if adjacentNode is not visited:
            DFS(Graph, adjacentNode)

MIN-MAx:
MINIMAX(node, depth, isMaxPlayer):
    IF node is a terminal node OR depth = 0:
        RETURN value of node
    IF isMaxPlayer = TRUE:
        bestValue ← -∞
        FOR each child of node:
            value ← MINIMAX(child, depth - 1, FALSE)
            bestValue ← MAX(bestValue, value)
        RETURN bestValue
    ELSE:
        bestValue ← +∞
        FOR each child of node:
            value ← MINIMAX(child, depth - 1, TRUE)
            bestValue ← MIN(bestValue, value)
        RETURN bestValue

Alpha–Beta Pruning – Pseudocode:
ALPHABETA(node, depth, α, β, isMaxPlayer):
    IF node is a terminal node OR depth = 0:
        RETURN value of node
    IF isMaxPlayer = TRUE:
        value ← -∞
        FOR each child of node:
            value ← MAX(value,
                         ALPHABETA(child, depth - 1, α, β, FALSE))
            α ← MAX(α, value)
            IF α ≥ β:
                BREAK   // β cut-off (pruning)
        RETURN value
    ELSE:
        value ← +∞
        FOR each child of node:
            value ← MIN(value,
                         ALPHABETA(child, depth - 1, α, β, TRUE))
            β ← MIN(β, value)
            IF β ≤ α:
                BREAK   // α cut-off (pruning)
        RETURN value
